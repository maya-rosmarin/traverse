{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./maze.js","webpack:///./maze_generators/create_grid.js","webpack:///./maze_generators/dfs.js","webpack:///./maze_generators/dfs_util.js","webpack:///./maze_generators/dfs_weighted.js","webpack:///./maze_generators/kruskal.js","webpack:///./maze_generators/prims.js","webpack:///./maze_solvers/bfs.js","webpack:///./node_modules/manhattan/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACyF;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;ACzDD;;AAEA;AACA;AACA,sBAAsB,WAAW;AACjC,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,kBAAkB,eAAe;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpIA;AAC6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;AClG6C;;AAE7C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AAC6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;;;;ACtE4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd,cAAc;AACd,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,WAAW;AAC9B,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5H0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC5MA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnHA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./maze.js\");\n","import DFS from './maze_generators/dfs';\nimport DFSWeighted from './maze_generators/dfs_weighted';\nimport DFSUtil from './maze_generators/dfs_util';\nimport Kruskal from './maze_generators/kruskal';\nimport Prims from './maze_generators/prims';\nimport { createGridArray, createGridGraphic, createGridStatic, init, isScrolledIntoView } from './maze_generators/create_grid';\nimport BFS from './maze_solvers/bfs';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  createGridStatic();\n  init();\n  let weighted = document.getElementById('dfs-weighted-run');\n  let dfsWeighted = new DFSWeighted(40, 40, 'canvas-4');\n  weighted.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n    dfsWeighted.animate([-2, 0]);\n  });\n  let weightedReset = document.getElementById('dfs-weighted-reset');\n  weighted.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n    dfsWeighted.clearCanvas();\n  });\n  let dfsCanvas = document.getElementById('dfs-random-run');\n  let dfs = new DFS(40, 40, 'canvas-1');\n  dfsCanvas.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n    dfs.animate([0,0]);\n  });\n  let dfsReset = document.getElementById('dfs-random-reset');\n  dfsReset.addEventListener(\"click\", (event) => {\n    event.preventDefault();\n    dfs.clearCanvas();\n  })\n  let bfsCanvas = document.getElementById('bfs-solver-run');\n  bfsCanvas.addEventListener(\"click\", () => {\n    let bfs = new BFS([0, 0], [38, 38]);\n    bfs.dfs.animate([0,0], () => bfs.animate(bfs.exploreNodes(), 'white'))\n  });\n  let bfsReset = document.getElementById('bfs-solver-reset');\n  bfsReset.addEventListener(\"click\", () => {\n    bfs.clearCanvas();\n  })\n  let kruskal = document.getElementById('kruskal-run');\n  let kruskalCanvas = new Kruskal(40, 40);\n  kruskal.addEventListener(\"click\", () => {\n    kruskalCanvas.animate();\n  });\n  let kruskalReset = document.getElementById('kruskal-reset');\n  kruskalReset.addEventListener(\"click\", () => {\n    kruskalCanvas.clearCanvas();\n  });\n  let prims = new Prims(40, 40);\n  prims.isNeighbor([2,2], [0,0])\n  prims.connectCells();\n  prims.animate();\n  // let dfsutil = new DFSUtil(5, 5, 'canvas-7');\n  // dfsutil.generatePaths([0,0]);\n});\n","import * as manhattan from 'manhattan';\n\nexport const createGridArray = (width, height, start1 = 0, start2 = 0) => {\n  let nodes = [];\n  for (let i = start1; i < width; i+=2) {\n    for (let j = start2; j < height; j+=2) {\n      nodes.push([i, j, false]);\n    }\n  }\n  return nodes;\n}\n\nexport const createWallsArray = (height, width) => {\n  let walls = [];\n  for (let i = 0; i < width + 1; i++) {\n    for (let j = 0; j < height + 1; j++) {\n      // either i or j is odd\n      if (i % 2 !== 0 ^ j % 2 !== 0) {\n        walls.push([i, j])\n      }\n    }\n  }\n  return walls;\n}\n\nexport const createGridGraphic = (width, height) => {\n  let canvas = document.getElementById(\"canvas-1\");\n  let context = canvas.getContext(\"2d\");\n  context.fillStyle = 'black';\n  context.fillRect(0, 0, width + 10, height + 10);\n  context.fillStyle = '#B7979C';\n  context.fillRect(width, height - 10, 10, 10);\n}\n\nexport const createGridStatic = (width, height) => {\n  let canvas = document.getElementById(\"canvas-2\");\n  let context = canvas.getContext(\"2d\");\n  context.fillStyle = '#d6c4c7';\n  context.fillRect(0, 0, 500, 500);\n  let bw = 500;\n  let bh = 500;\n  let p = 0;\n  function drawGrid () {\n    for (let i = 0; i <= bw; i += 50) {\n      context.moveTo(0.5 + i, 0);\n      context.lineTo(0.5 + i, bh);\n    }\n    for (let j = 0; j <= bh; j += 50) {\n      context.moveTo(0, 0.5 + j);\n      context.lineTo(bw, 0.5 + j);\n    }\n    context.strokeStyle = 'black';\n    context.stroke();\n  }\n  context.fillStyle = '#A67D7D';\n  for (let k = 0; k < 450; k += 100) {\n    context.fillRect(k, 0, 50, 2000)\n    context.fillRect(0, k, 2000, 50)\n  }\n  context.fillStyle = '#d6c4c7';\n  let l = 100;\n  let m = 50;\n  let interval = setInterval(() => {\n    context.fillRect(l, m, 50, 50)\n    if (l > 250) {\n      l = 0;\n      m += 100;\n    } else if (m > 350) {\n      clearInterval(interval);\n    }\n    l += 100;\n  }, 670)\n}\n\nexport const init = () => {\n  updateCanvas();\n}\n\nfunction updateCanvas () {\n  let width = 500;\n  let height = 500;\n  let myCanvas = document.getElementById(\"canvas-3\");\n    myCanvas.width = width;\n    myCanvas.height = height;\n\n  let context = myCanvas.getContext(\"2d\");\n    context.clearRect(0,0,width,height);\n    context.fillStyle = \"white\";\n    context.fillRect(0,0,width,height);\n\n    let rad=10;\n    let gaps= rad*2;\n    let widthCount = parseInt(width/gaps);\n    let heightCount = parseInt(height/gaps);\n    let coords = []\n    for(let x=0; x<widthCount;x++){\n      for(let y=0; y<heightCount;y++){\n        if (x % 2 === 0 || y % 2 === 0) {\n          context.fillStyle = '#996D73';\n        } else {\n          context.fillStyle = '#d6c4c7'\n        }\n        context.beginPath();\n        context.arc(rad+gaps*x,rad+ gaps*y, rad, 0, Math.PI*2, true );\n        context.closePath();\n        context.fill();\n      }\n      let x2 = 2;\n      let y2 = 1;\n      let interval = setInterval(() => {\n        context.beginPath();\n        context.arc(rad+gaps*x2,rad+ gaps*y2, rad, 0, Math.PI*2, true );\n        context.closePath();\n        context.fill();\n        if (x2 === 22) {\n          x2 = 0;\n          y2 += 2;\n        } else if (y2 === 22) {\n          clearInterval(interval);\n        }\n        x2++;\n      }, 100)\n      context.fillStyle = '#d6c4c7';\n    }\n}\n\nexport const isScrolledIntoView = (el) => {\n    let rect = el.getBoundingClientRect();\n    let elemTop = rect.top;\n    let elemBottom = rect.bottom;\n    let isVisible = (elemTop >= 0) && (elemBottom <= window.innerHeight);\n    return isVisible;\n}\n","import * as manhattan from 'manhattan';\nimport { createGridArray, createGridGraphic } from './create_grid';\nimport * as DFSUtil from './dfs_util';\n\nexport default class DFS {\n  constructor (width, height, canvasId) {\n    this.grid = createGridArray(width, height);\n    createGridGraphic(width*10, height*10);\n    this.canvasId = canvasId;\n    this.width = width;\n    this.height = height;\n    this.stack = []\n  }\n\n  clearCanvas () {\n    let canvas = document.getElementById(this.canvasId);\n    let context = canvas.getContext('2d');\n    context.clearRect(10, 10, canvas.width, canvas.height);\n  }\n\n  animate (startNode, callback, fillColor) {\n    let canvas = document.getElementById(this.canvasId);\n    let context = canvas.getContext(\"2d\");\n    let path = this.generatePaths(startNode);\n    let connector;\n    context.fillStyle='#B7979C'\n    let i = 0;\n    let interval = setInterval( () => {\n      if (i === 0) {\n        connector = null;\n      } else {\n        connector = DFSUtil.connector(path[i-1], path[i])\n      }\n      if (connector) {\n        context.fillRect(10*connector[0] + 10, 10*connector[1] + 10, 10, 10)\n      }\n      context.fillRect(10*path[i][0] + 10, 10*path[i][1] + 10, 10, 10);\n      i++;\n      if (i >= path.length) {\n        clearInterval(interval);\n        context.fillRect(410, 400, 10, 10)\n        document.getElementById(\"real-thing\").innerHTML = 'Looks like the real thing!'\n        if (callback) {\n          document.getElementById(\"solved\").innerHTML = 'Solving...'\n          return callback();\n        }\n        return 'finished';\n      }\n    }, 20);\n  }\n\n  generatePaths (startNode) {\n    startNode[2] = true;\n    this.stack.push(startNode);\n    let last = startNode;\n    while (DFSUtil.unvisited(this.grid).length) {\n      let step = this.nextStep(last);\n      if (!step) {\n        last = this.backtrack(-1);\n      } else {\n        step[2] = true;\n        this.stack.push(step);\n        last = this.stack.slice(-1)[0];\n      }\n    }\n    return this.stack;\n  }\n\n  nextStep (startNode) {\n    let neighbors = this.neighbors(startNode).filter(neighbor => !DFSUtil.isVisited(neighbor));\n    if (neighbors == null || neighbors.length == 0) {\n      return null;\n    }\n    let randomIndex = Math.floor(Math.random() * neighbors.length);\n    return neighbors[randomIndex];\n  }\n\n  backtrack (n) {\n    let current = this.stack.slice(n)[0];\n    if (this.nextStep(current)) {\n      this.stack.push(current)\n      return current;\n    } else {\n      n--;\n      return this.backtrack(n);\n    }\n  }\n\n  neighbors (startNode) {\n    let nodes = [];\n    this.grid.forEach((node) => {\n      if ((startNode[0] == node[0] && startNode[1] == node[1] + 2) || (startNode[0] == node[0] && startNode[1] == node[1] - 2) || (startNode[0] == node[0] + 2 && startNode[1] == node[1]) || (startNode[0] == node[0] - 2 && startNode[1] == node[1])) {\n        nodes.push(node);\n      }\n    })\n    return nodes;\n  }\n\n}\n","import { createGridArray, createGridGraphic } from './create_grid';\n\n  export const connector = (startNode, node) => {\n    let connector;\n      if (startNode[0] == node[0] && startNode[1] == node[1] + 2) {\n        connector = [node[0], node[1] + 1];\n      } else if (startNode[0] == node[0] && startNode[1] == node[1] - 2) {\n        connector = [node[0], node[1] - 1];\n      } else if (startNode[0] == node[0] + 2 && startNode[1] == node[1]) {\n        connector = [node[0] + 1, node[1]];\n      } else if (startNode[0] == node[0] - 2 && startNode[1] == node[1]) {\n        connector = [node[0] - 1, node[1]];\n      }\n    return connector;\n  }\n\n  export const generatePaths = (startNode) => {\n    startNode[2] = true;\n    this.stack.push(startNode);\n    let last = startNode;\n    while (this.unvisited().length) {\n      let step = this.nextStep(last);\n      if (!step) {\n        last = this.backtrack(-1);\n      } else {\n        step[2] = true;\n        this.stack.push(step);\n        last = this.stack.slice(-1)[0];\n      }\n    }\n    return this.stack;\n  }\n\n  export const unvisited = (grid) => {\n    return grid.filter(cell => cell[2] === false)\n  }\n\n  export const isVisited = (node) => {\n    return node[2] === true\n  }\n\n  export const backtrack = (n, stack, callback) => {\n    let current = stack.slice(n)[0];\n    if (callback(current)) {\n      stack.push(current)\n      return current;\n    } else {\n      n--;\n      return backtrack(n);\n    }\n  }\n\n  export const neighbors = (startNode, grid) => {\n    let nodes = [];\n    grid.forEach((node) => {\n      if ((startNode[0] == node[0] && startNode[1] == node[1] + 2) || (startNode[0] == node[0] && startNode[1] == node[1] - 2) || (startNode[0] == node[0] + 2 && startNode[1] == node[1]) || (startNode[0] == node[0] - 2 && startNode[1] == node[1])) {\n        nodes.push(node);\n      }\n    })\n    return nodes;\n  }\n","import * as manhattan from 'manhattan';\nimport { createGridArray, createGridGraphic } from './create_grid';\nimport * as DFSUtil from './dfs_util';\n\nexport default class DFSWeighted {\n  constructor (width, height, canvasId) {\n    this.grid = createGridArray(width, height);\n    createGridGraphic(width*10, height*10);\n    this.canvasId = canvasId;\n    this.stack = []\n  }\n\n  clearCanvas () {\n    let canvas = document.getElementById(this.canvasId);\n    let context = canvas.getContext('2d');\n    context.clearRect(10, 10, canvas.width, canvas.height);\n  }\n\n  animate (startNode) {\n    let canvas = document.getElementById(this.canvasId);\n    let context = canvas.getContext(\"2d\");\n    let path = this.generatePaths(startNode);\n    let connector;\n    let i = 0;\n    let interval = setInterval( () => {\n      if (i === 0) {\n        connector = null;\n      } else {\n        connector = DFSUtil.connector(path[i-1], path[i])\n      }\n      if (connector) {\n        context.fillRect(10*connector[0], 10*connector[1], 10, 10) }\n        context.fillRect(10*path[i][0], 10*path[i][1], 10, 10);\n        i++;\n        if (i >= path.length) {\n          clearInterval(interval);\n        }\n      }, 20);\n      context.fillStyle='#B7979C';\n      context.fillRect(0, 10, 10, 10);\n  }\n\n  generatePaths (startNode) {\n    startNode[2] = true;\n    this.stack.push(startNode);\n    let last = startNode;\n    while (DFSUtil.unvisited(this.grid).length) {\n      let step = this.nextStep(last);\n      if (!step) {\n        last = this.backtrack(-1);\n      } else {\n        step[2] = true;\n        this.stack.push(step);\n        last = this.stack.slice(-1)[0];\n      }\n    }\n    return this.stack;\n  }\n\n  nextStep (startNode) {\n    let neighbors = DFSUtil.neighbors(startNode, this.grid).filter(neighbor => !DFSUtil.isVisited(neighbor));\n    if (neighbors == null || neighbors.length == 0) {\n      return null;\n    }\n    neighbors = neighbors.sort((node1, node2) => {\n      return manhattan(node1.slice(-1)[0], [18, 18]) - manhattan(node2.slice(-1)[0], [18, 18])\n    });\n    return neighbors[0];\n  }\n\n}\n","import { createGridArray, createWallsArray } from './create_grid';\n\nexport default class Kruskal {\n  constructor (width, height) {\n    this.grid = createGridArray(width, height);\n    this.sets = this.createSets(width, height);\n    this.edges = this.shuffle(this.createEdges(width, height));\n    this.fill = [];\n    this.connectNodes()\n  }\n\n  clearCanvas () {\n    let canvas = document.getElementById('canvas-6');\n    let context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  animate (callback) {\n    let canvas = document.getElementById('canvas-6');\n    let context = canvas.getContext(\"2d\");\n    let fill = this.fill;\n    context.fillStyle='white';\n    let i = 0;\n    let interval = setInterval( () => {\n      context.fillRect(10*fill[i][0], 10*fill[i][1], 10, 10);\n      i++;\n      if (i >= fill.length) {\n        if (callback) {\n          return callback();\n        }\n        clearInterval(interval);\n      }\n    }, 2);\n  }\n\n  connectNodes () {\n    let dY = {'e': 2, 'w': -2, 'n': 0, 's': 0};\n    let dX = {'e': 0, 'w': 0, 'n': -2, 's': 2};\n    let oppositeDirections = {'e': 'w', 'w': 'e', 'n': 's', 's': 'n'};\n    while (this.edges.length > 0) {\n      let x = this.edges[0][0];\n      let y = this.edges[0][1];\n      let direction = this.edges[0][2];\n      let nx = x + dX[direction];\n      let ny = y + dY[direction];\n      this.edges.shift();\n      let set1 = this.findSetByLocation(x, y);\n      let set2 = this.findSetByLocation(nx, ny);\n      if (!set1.isConnected(set2)) {\n        set1.connect(set2);\n        this.fill.push(set1.location);\n        this.fill.push(set2.location);\n        this.fill.push(this.wall(set1.location, set2.location))\n        this.findCellByLocation(x, y)[2] = direction;\n        this.findCellByLocation(nx, ny)[2] = oppositeDirections[direction];\n      }\n    }\n    return this.fill;\n  }\n\n  createSets (width, height) {\n    let sets = [];\n    for (let i = 0; i < this.grid.length; i++) {\n      sets.push(new Tree([this.grid[i][0],this.grid[i][1]]))\n    }\n    return sets;\n  }\n\n  createEdges (width, height) {\n    let edges = [];\n    for (let i = 0; i < width; i+=2) {\n      for (let j = 0; j < height; j+=2) {\n        if (i > 0) {\n          edges.push([i, j, 'n'])\n        }\n        if (j > 0) {\n          edges.push([i, j, 'w'])\n        }\n      }\n    }\n    return edges;\n  }\n\n  shuffle (array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  findSetByLocation (xCoord, yCoord) {\n    return this.sets.find(set => set.location[0] === xCoord && set.location[1] === yCoord);\n  }\n\n  findCellByLocation (xCoord, yCoord) {\n    return this.grid.find(cell => cell[0] === xCoord && cell[1] === yCoord);\n  }\n\n  wall (node1, node2) {\n    let xCoord = (node1[0] + node2[0])/2;\n    let yCoord = (node1[1] + node2[1])/2;\n    return [xCoord, yCoord];\n  }\n\n};\n\nclass Tree {\n  constructor (location) {\n    this.parent = null;\n    this.location = location;\n  }\n\n  root () {\n    return this.parent ? this.parent.root() : this\n  }\n\n  isConnected (tree) {\n    return this.root() === tree.root();\n  }\n\n  connect (tree) {\n    return tree.root().parent = this;\n  }\n}\n","import { createGridArray } from './create_grid';\n\nconst IN = 0x10;\nconst FRONTIER = 0x20;\n\nexport default class Prims {\n  constructor (width, height) {\n    this.grid = createGridArray(width, height);\n    this.width = width;\n    this.height = height;\n    this.frontier = [];\n    this.fill = [];\n  }\n\n  connectCells () {\n      let startNode = this.randomElement(this.grid);\n      this.fill.push(startNode);\n      this.mark(startNode[0], startNode[1]);\n      while (this.frontier.length) {\n        let nextNode = this.randomElement(this.frontier);\n        if (!nextNode) {\n          debugger;\n        }\n        if (nextNode) {\n          this.mark(nextNode[0], nextNode[1]);\n          let last = this.fill[this.fill.length - 1];\n          this.fill.push(nextNode);\n          // this.fill.push(this.wall(last, nextNode));\n          delete this.frontier[this.frontier.indexOf(nextNode)];\n          this.frontier = this.filter(this.frontier);\n        }\n      }\n      debugger\n      console.log(this.fill);\n      let path = this.animatePath();\n      console.log(path)\n      return this.fill;\n  }\n\n  mark (xCoord, yCoord) {\n    // this.findCellByLocation(xCoord, yCoord)[2] = IN\n    this.addFrontier(xCoord-2, yCoord)\n    this.addFrontier(xCoord+2, yCoord)\n    this.addFrontier(xCoord, yCoord-2)\n    this.addFrontier(xCoord, yCoord+2)\n  }\n\n  addFrontier(xCoord, yCoord) {\n    if (xCoord >= 0 && yCoord >= 0 && xCoord < this.width && yCoord < this.height && !this.arrayIncludes(this.fill, [xCoord, yCoord])) {\n      this.findCellByLocation(xCoord, yCoord)[2] = FRONTIER;\n      this.frontier.push([xCoord, yCoord]);\n    }\n  }\n\n  neighbors (xCoord, yCoord) {\n    let neighbors = [];\n    if (xCoord > 0 && this.findCellByLocation(yCoord, xCoord - 2)) {\n      neighbors.push(this.findCellByLocation(xCoord - 2, yCoord));\n    }\n    if (xCoord + 2 < this.width && this.findCellByLocation(yCoord, xCoord + 2)) {\n      neighbors.push(this.findCellByLocation(xCoord + 2, yCoord));\n    }\n    if (yCoord > 0 && this.findCellByLocation(yCoord - 2, xCoord)) {\n      neighbors.push(this.findCellByLocation(xCoord, yCoord - 2));\n    }\n    if (yCoord + 2 < this.height && this.findCellByLocation(yCoord + 2, xCoord)) {\n      neighbors.push(this.findCellByLocation(xCoord, yCoord + 2));\n    }\n    return neighbors;\n  }\n\n\n  findCellByLocation (xCoord, yCoord) {\n    return this.grid.find(cell => cell[0] === xCoord && cell[1] === yCoord);\n  }\n\n  findFrontierByLocation (xCoord, yCoord) {\n    for (let i = 0; i < this.frontier.length; i++) {\n      if (this.frontier[i] && this.frontier[i][0] === xCoord && this.frontier[i][1] === yCoord) {\n        return this.frontier[i]\n      }\n    }\n  }\n\n  shuffle (array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n  }\n\n  randomElement (array) {\n    let randomIndex = Math.floor(Math.random() * array.length);\n    if (!array[randomIndex]) {\n      this.randomElement(array);\n    } else {\n      return array[randomIndex];\n    }\n  }\n\n  filter (array) {\n    let filtered = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i] !== undefined && array[i] != null) {\n        filtered.push(array[i])\n      }\n    }\n    return filtered;\n  }\n\n  arrayIncludes (array, node) {\n    for (let i = 0; i < array.length; i++) {\n      if (array[i][0] == node[0] && array[i][1] == node[1]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  wall (node1, node2) {\n    let xCoord = (node1[0] + node2[0])/2;\n    let yCoord = (node1[1] + node2[1])/2;\n    return [xCoord, yCoord];\n  }\n\n  // animatePath () {\n  //   debugger\n  //   let path = [];\n  //   let connectors = [];\n  //   for (let i = 0; i < this.fill.length; i++) {\n  //     debugger\n  //     let node = this.fill[i];\n  //     if (this.isNeighbor(node, this.fill[i+1])) {\n  //       path.push(node);\n  //       path.push(this.wall(node, this.fill[i+1]));\n  //     } else {\n  //       let neighbors = this.neighbors(this.fill[i][0], this.fill[i][1]);\n  //       for (let j = 0; j < neighbors.length; j++) {\n  //         if (this.arrayIncludes(path, neighbors[j])) {\n  //           connectors.push(neighbors[j])\n  //         };\n  //       }\n  //       path.push(this.wall(this.fill[i], this.randomElement(connectors)));\n  //       path.push(this.fill[i])\n  //     }\n  //   }\n  //   debugger\n  //   return path;\n  // }\n\n  animatePath () {\n    debugger\n    let path = [this.fill[0]];\n    for (let i = 1; i < this.fill.length; i++) {\n      let last = path[path.length - 1];\n      if (this.isNeighbor(this.fill[i], last)) {\n        path.push(this.wall(this.fill[i], last));\n        path.push(this.fill[i]);\n      } else {\n        let neighbors = this.neighbors(this.fill[i][0], this.fill[i][1]);\n        for (let j = 0; j < neighbors.length; j++) {\n          if (this.arrayIncludes(path, neighbors[j])) {\n            path.push(this.wall(neighbors[j], this.fill[i]));\n            path.push(this.fill[i]);\n            break;\n          }\n        }\n      }\n    }\n    return path;\n  }\n\n  isNeighbor (node1, node2) {\n    let neighbors = this.neighbors(node1[0], node1[1]);\n    if (this.arrayIncludes(neighbors, node2)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  animate () {\n    let canvas = document.getElementById('canvas-7');\n    let context = canvas.getContext(\"2d\");\n    context.fillStyle='#B7979C';\n    // context.fillRect(0, 0, 10, 10);\n    // let fill = this.filter(this.fill);\n    let fill = this.filter(this.animatePath())\n    let i = 0;\n    let interval = setInterval( () => {\n      if (!fill[i]) {\n        debugger\n      }\n      context.fillRect(10*fill[i][0], 10*fill[i][1], 10, 10);\n      i++;\n      if (i >= fill.length) {\n        // if (callback) {\n        //   return callback();\n        // }\n        clearInterval(interval);\n      }\n    }, 5);\n  }\n}\n","import DFS from '../maze_generators/dfs';\n\nexport default class BFS {\n  constructor (startNode, targetNode) {\n    this.startNode = startNode;\n    this.targetNode = targetNode;\n    this.dfs = new DFS(40, 40, 'canvas-5');\n    this.maze = this.dfs.generatePaths([0,0]);\n    this.mazePaths = this.moves();\n    this.dfs.animate([0,0], () => this.animate(this.exploreNodes(), '#cbb3b7'))\n  }\n\n  clearCanvas () {\n    let canvas = document.getElementById('canvas-5');\n    let context = canvas.getContext('2d');\n    context.clearRect(0, 0, canvas.width, canvas.height);\n  }\n\n  animate (path, fillColor) {\n    let canvas = document.getElementById(\"canvas-5\");\n    let context = canvas.getContext(\"2d\");\n    context.fillRect(0, 10, 10, 10);\n    context.fillRect(400, 390, 10, 10);\n    context.fillStyle=fillColor;\n    let connector;\n    let i = 0;\n    let interval = setInterval(() => {\n        // if (i === 0) {\n        //   connector = null;\n        // } else {\n        //   connector = this.dfs.connector(path[i-1], path[i])\n        // }\n        // if (connector) {\n        //   context.fillRect(10*connector[0] + 10, 10*connector[1] + 10, 10, 10)\n        // }\n        context.fillStyle=fillColor;\n        context.fillRect(10*path[i][0] + 10, 10*path[i][1] + 10, 10, 10);\n        i++;\n        document.getElementById(\"solved\").innerHTML = 'Solving...'\n\n      if (i >= path.length) {\n        document.getElementById(\"solved\").innerHTML = 'Solved!'\n        clearInterval(interval);\n      }\n    }, 30)\n  }\n\n  exploreNodes () {\n    let queue = [this.startNode];\n    let visited = [this.startNode];\n    let path = [this.startNode];\n    while (queue.length) {\n      let current = queue.shift();\n      let neighbors = this.neighbors(current);\n      for (let i = 0; i < neighbors.length; i++) {\n        if (!this.arrayIncludes(visited, neighbors[i]) && this.mazePathsIncludes([current, neighbors[i]])) {\n          queue.push(neighbors[i]);\n          path.push(neighbors[i]);\n          visited.push(neighbors[i]);\n        };\n        if (this.isSameNode(neighbors[i], this.targetNode)) {\n          queue.push(neighbors[i]);\n          path.push(neighbors[i]);\n          visited.push(neighbors[i]);\n          return path;\n        }\n      }\n    }\n  }\n\n  neighbors (startNode) {\n    let neighbors = [];\n    this.maze.forEach((node) => {\n      if ((startNode[0] == node[0] && startNode[1] == node[1] + 2) || (startNode[0] == node[0] && startNode[1] == node[1] - 2) || (startNode[0] == node[0] + 2 && startNode[1] == node[1]) || (startNode[0] == node[0] - 2 && startNode[1] == node[1])) {\n        neighbors.push(node);\n      }\n    })\n    return neighbors;\n  }\n\n  moves () {\n    let moves = [];\n    this.maze.forEach((node, idx) => {\n        if (idx === 0) {\n          return;\n        } else {\n          moves.push([this.maze[idx-1], node])\n        }\n      }\n    )\n    return moves;\n  }\n\n  isSameNode (node1, node2) {\n    return node1[0] === node2[0] && node1[1] === node2[1];\n  }\n\n  arrayIncludes (array, node) {\n    for (let i = 0; i < array.length; i++) {\n      if (array[i][0] == node[0] && array[i][1] == node[1]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  mazePathsIncludes (nodesArr) {\n    for (let i = 0; i < this.mazePaths.length; i++) {\n      if (this.arrayIncludes(this.mazePaths[i], nodesArr[0]) && this.arrayIncludes(this.mazePaths[i], nodesArr[1])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n}\n","module.exports = function distance(a, b) {\n  var distance = 0\n  var dimensions = Math.max(a.length, b.length)\n  for (var i = 0; i < dimensions; i++) {\n    distance += Math.abs((b[i] || 0) - (a[i] || 0))\n  }\n  return distance\n}\n"],"sourceRoot":""}