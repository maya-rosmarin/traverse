<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Traverse</title>
    <script src="./dist/bundle.js"></script>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
    <link rel="icon" href="./dist/favicon-th.ico" sizes="32x32">
    <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet">
    <link rel="stylesheet" href="application.css">
  </head>
  <body>
    <div class="exp-and-maze">
      <div class="explanation-block">
        <h1>Traverse</h1>
        <h3 class="contact">Maya Rosmarin</h3>
        <ul class="contact-list">
          <a class="contact" href="https://github.com/maya-rosmarin"><i class="fab fa-github"></i></a>
          <a class="contact" href="https://www.linkedin.com/in/maya-rosmarin-170794b5/"><i class="fab fa-linkedin"></i></a>
          <a class="contact" href="https://angel.co/maya-rosmarin"><i class="fab fa-angellist"></i></a>
        </ul>
        <p class="explanation">To break down the problem of maze generation, it is helpful to visualize a maze as a grid or a graph of cells.</p>
        <p class="explanation">Each cell is either a node or a wall. In the graphs to the right, each light pink node is surrounded by a dark pink wall on all four sides. To connect two nodes, remove the wall separating them, transforming that wall into path.</p>
    </div>
      <div class="grids">
        <canvas height=450 width=450 id="canvas-2"></canvas>
        <canvas height=500 width=500 id="canvas-3"></canvas>
      </div>
    </div>
    <div class="exp-and-maze">
      <div class="maze-and-buttons">
        <canvas height=390 width=380 id="canvas-4"></canvas>
        <div id="dfs-weighted">
          <input type="button" value="Run" class="dfs-weighted" id="dfs-weighted-run" />
          <input type="button" value="Reset" class="dfs-weighted" id="dfs-weighted-reset" />
        </div>
      </div>
      <div class="explanation-block">
        <p class="explanation">Now that we can connect two nodes to each other, we can connect every node to one single path, essentially a spanning tree of the graph. Every node must be connected to exactly two of its neighbors - the one that approaches it, and the one that it approaches.</p>
        <p class="explanation">Now that we have a rough understanding of the mechanics of the maze, we can work on the decision engine that controls the order of the graph traversal.</p>
        <p class="explanation">To the left you can see a maze generated by an implementation of DFS. At each node in the graph, the algorithm generates a collection of all neighboring and unvisited nodes, an array of length between one and three. It then sorts them by Manhattan distance to the destination node in the bottom right corner, and selects the closest one.</p>
      </div>
    </div>
    <div class="dfs-block">
      <div class="explanation-block">
        <p class="explanation">The above approach works, but in order to generate a maze that looks like a maze, we will randomly select a node from a list of neighboring nodes, rather than sorting them by proximity to the destination.</p>
        <p class="explanation" id="real-thing"> --- </p>
      </div>
      <canvas height=400 width=400 id="canvas-1"></canvas>
    </div>
    <div id="dfs-random">
      <input type="button" value="Run" class="dfs-weighted" id="dfs-random-run" />
      <input type="button" value="Reset" class="dfs-weighted" id="dfs-random-reset" />
    </div>
    <div class="exp-and-maze">
      <div class="maze-and-buttons">
        <canvas height=400 width=400 id="canvas-5"></canvas>
        <div id="bfs-solver">
          <input type="button" value="Run" class="dfs-weighted" id="bfs-solver-run" />
          <input type="button" value="Reset" class="dfs-weighted" id="bfs-solver-reset" />
        </div>
      </div>
      <div class="explanation-block">
        <p class="explanation">Now that we have a maze generated, let's get to work on solving it.</p>
        <p class="explanation">The maze solver to the left is an implementation of BFS. Provided the paths in the existing maze, the algorithm generates a queue of the starting node's neighbors, then the neighbors' neighbors and so on. It continues discovering neighboring nodes until it reaches the specified target node.</p>
        <p class="explanation" id="solved"> Generating... </p>
      </div>
    </div>
    <div class="exp-and-maze">
      <div class="explanation-block">
        <p class="explanation">Kruskal's algorithm is substantially more complex than either BFS or DFS. In the maze to the right, each cell on the graph can be conceived of as its own disjoint set. Beyond just ensuring that every node on the graph has been visited, it is crucial that every node on the graph belongs to the same joined set, in this case, a tree with the same root node. </p>
        <p class="explanation">To introduce some randomness to the maze, every wall - the joining element between two disparate sets - is shuffled and selected at random until the set is joined.</p>
      </div>
      <canvas height=400 width=400 id="canvas-6"></canvas>
    </div>
    <div id="kruskal">
      <input type="button" value="Run" class="dfs-weighted" id="kruskal-run" />
      <input type="button" value="Reset" class="dfs-weighted" id="kruskal-reset" />
    </div>
    <div class="exp-and-maze">
      <div class="maze-and-buttons">
        <canvas height=400 width=400 id="canvas-7"></canvas>
        <div id="prims">
          <input type="button" value="Run" class="dfs-weighted" id="prims-run" />
          <input type="button" value="Reset" class="dfs-weighted" id="prims-reset" />
        </div>
      </div>
    </div>
  </body>
</html>
