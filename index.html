<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Traverse</title>
    <script src="./dist/bundle.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet">
    <link rel="stylesheet" href="application.css">
  </head>
  <body>
    <div class="exp-and-maze">
      <div class="explanation-block">
        <h1>Traverse</h1>
        <p class="explanation">To break down the problem of maze generation, it is helpful to visualize a maze as a grid or a graph of cells.</p>
        <p class="explanation">Each cell is either a node or a wall. In the graphs to the right, each node is surrounded by a wall on all four sides. To connect two nodes, remove the wall separating them, transforming that wall into path.</p>
    </div>
      <div class="grids">
        <canvas height=450 width=450 id="canvas-2"></canvas>
        <canvas height=500 width=500 id="canvas-3"></canvas>
      </div>
    </div>
    <div class="exp-and-maze">
      <canvas height=500 width=500 id="canvas-4"></canvas>
      <div class="explanation-block">
        <p class="explanation">Now that we can connect two nodes to each other, we can connect every node to one single path, essentially a spanning tree of the graph. So every node must be connected to exactly two of it's neighbors - the one that approaches it, and the one that it approaches.</p>
        <p class="explanation">Now that we have rough understanding of the mechanics of the maze, we can work on the decision engine that controls the order of the graph traversal.</p>
        <p class="explanation">To the left is a maze generated by an implementation of DFS. At each node in the graph, the algorithm generates a collection of all neighboring and unvisited nodes, an array of length between one and three. It then sorts them by Manhattan distance to the destination node in the bottom right corner, and selects the closest one.</p>
      </div>
    </div>
    <div class="dfs-block">
      <div class="explanation-block">
        <p class="explanation">The above approach works, but in order to generate a maze that looks like a maze, we will randomly select a node from an unsorted list of neighboring nodes, rather than sorting them by proximity to the destination.</p>
        <p class="explanation">Looks like the real thing!</p>
      </div>
      <canvas height=500 width=500 id="canvas-1"></canvas>
    </div>
    <div>
      <div class="exp-and-maze">
        <canvas height=500 width=500 id="canvas-5"></canvas>
        <div class="explanation-block">
          <p class="explanation">Now that we have a maze generated, let's get to work on solving it.</p>
        </div>
      </div>
    </div>
  </body>
</html>
