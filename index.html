<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Traverse</title>
    <script src="./dist/bundle.js"></script>
    <link rel="icon" href="./dist/favicon-th.ico" sizes="32x32">
    <link href="https://fonts.googleapis.com/css?family=Source+Serif+Pro" rel="stylesheet">
    <link rel="stylesheet" href="application.css">
  </head>
  <body>
    <div class="exp-and-maze">
      <div class="explanation-block">
        <h1>Traverse</h1>
        <p class="explanation">To break down the problem of maze generation, it is helpful to visualize a maze as a grid or a graph of cells.</p>
        <p class="explanation">Each cell is either a node or a wall. In the graphs to the right, each light gray node is surrounded by a dark gray wall on all four sides. To connect two nodes, remove the wall separating them, transforming that wall into path.</p>
    </div>
      <div class="grids">
        <canvas height=450 width=450 id="canvas-2"></canvas>
        <canvas height=500 width=500 id="canvas-3"></canvas>
      </div>
    </div>
    <div class="exp-and-maze">
      <canvas height=390 width=380 id="canvas-4"></canvas>
      <div class="explanation-block">
        <p class="explanation">Now that we can connect two nodes to each other, we can connect every node to one single path, essentially a spanning tree of the graph. Every node must be connected to exactly two of its neighbors - the one that approaches it, and the one that it approaches.</p>
        <p class="explanation">Now that we have a rough understanding of the mechanics of the maze, we can work on the decision engine that controls the order of the graph traversal.</p>
        <p class="explanation">Click on the box to the left to see a maze generated by an implementation of DFS. At each node in the graph, the algorithm generates a collection of all neighboring and unvisited nodes, an array of length between one and three. It then sorts them by Manhattan distance to the destination node in the bottom right corner, and selects the closest one.</p>
      </div>
    </div>
    <div class="dfs-block">
      <div class="explanation-block">
        <p class="explanation">The above approach works, but in order to generate a maze that looks like a maze, we will randomly select a node from a list of neighboring nodes, rather than sorting them by proximity to the destination.</p>
        <p class="explanation" id="real-thing"> --- </p>
      </div>
      <canvas height=400 width=400 id="canvas-1"></canvas>
    </div>
    <div class="exp-and-maze">
      <canvas height=400 width=400 id="canvas-5"></canvas>
      <div class="explanation-block">
        <p class="explanation">Now that we have a maze generated, let's get to work on solving it.</p>
        <p class="explanation">The maze solver to the left is an implementation of BFS. Provided the paths in the existing maze, the algorithm generates a queue of the starting node's neighbors, then the neighbors' neighbors and so on. It continues discovering neighboring nodes until it reaches the specified target node.</p>
        <p class="explanation" id="solved"> Generating... </p>
      </div>
    </div>
    <div class="exp-and-maze">
      <div class="explanation-block">
        <p class="explanation">Kruskal's algorithm is substantially more complex than either BFS or DFS. In the maze to the right, each cell on the graph can be conceived of as its own disjoint set. In this version, the sets have been implemented as trees. Beyond just ensuring that every node on the graph has been visited, it is crucial that every node on the graph belongs to the same joined set, i.e. a tree with the same root node. </p>
        <p class="explanation">To introduce some randomness to the maze, every wall - the joining element between two disparate sets - is shuffled.</p>
      </div>
      <canvas height=400 width=400 id="canvas-6"></canvas>
    </div>
    <canvas height=400 width=400 id="canvas-7"></canvas>
  </body>
</html>
